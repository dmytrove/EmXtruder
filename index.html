<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Floating GLB Models with OrbitControls</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
  <!-- Import map for module resolution -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Enhanced Lighting Setup
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    
    // Multiple directional lights for better coverage
    const lights = [
      { color: 0xffffff, intensity: 1.3, position: [1, 1, 1] },
      { color: 0xffd4b4, intensity: 1.0, position: [-1, 0.5, -1] },
      { color: 0xb4d4ff, intensity: 1.0, position: [0, -1, 1] },
      { color: 0xff9966, intensity: 0.7, position: [1, -1, -1] },
      { color: 0x66ccff, intensity: 0.7, position: [-1, 1, -1] }
    ];
    
    // Add point lights for better glass visibility
    const pointLights = [];
    const pointLightConfigs = [
      { color: 0xff0000, intensity: 0.5, position: [5, 0, 0], distance: 20 },
      { color: 0x00ff00, intensity: 0.5, position: [-5, 0, 0], distance: 20 },
      { color: 0x0000ff, intensity: 0.5, position: [0, 5, 0], distance: 20 },
      { color: 0xffff00, intensity: 0.5, position: [0, -5, 0], distance: 20 }
    ];

    // Add directional lights
    lights.forEach(light => {
      const directionalLight = new THREE.DirectionalLight(light.color, light.intensity);
      directionalLight.position.set(...light.position);
      scene.add(directionalLight);
    });

    // Add point lights and create helpers
    const lightHelpers = [];
    pointLightConfigs.forEach(config => {
      const pointLight = new THREE.PointLight(config.color, config.intensity, config.distance);
      pointLight.position.set(...config.position);
      scene.add(pointLight);
      pointLights.push(pointLight);
      
      const helper = new THREE.PointLightHelper(pointLight, 1);
      helper.visible = false;
      scene.add(helper);
      lightHelpers.push(helper);
    });

    // Add a spotlight for dramatic effect
    const spotlight = new THREE.SpotLight(0xffffff, 1);
    spotlight.position.set(0, 10, 0);
    spotlight.angle = Math.PI / 4;
    spotlight.penumbra = 0.1;
    spotlight.decay = 2;
    spotlight.distance = 200;
    scene.add(spotlight);
    
    const spotLightHelper = new THREE.SpotLightHelper(spotlight);
    spotLightHelper.visible = false;
    scene.add(spotLightHelper);

    // Add grid helper to visualize scale (1 unit = 1 cm)
    const gridHelper = new THREE.GridHelper(20, 20);
    scene.add(gridHelper);

    // Orbit Controls - position camera closer for better viewing of 10mm models
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 2, 20);  // Adjusted for better viewing of larger models
    controls.update();

    // List of available GLB files loaded from CSV
    let allGlbFiles = [];
    let loadedCount = 0;
    let failedCount = 0;
    let totalToLoad = 0;
    let loadingAttempted = false;
    
    // Loading function for the CSV file
    async function loadGlbFilesFromCSV() {
      try {
        const response = await fetch('./glb_files.csv');
        if (!response.ok) {
          throw new Error(`Failed to load CSV: ${response.status}`);
        }
        
        const csvText = await response.text();
        const rows = csvText.split('\n');
        
        allGlbFiles = []; // Reset the list
        
        // Skip header row and parse each line
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i].trim();
          if (!row) continue;
          
          // Parse CSV row, handling quoted values
          const columns = row.match(/("[^"]+"|[^,]+)/g);
          if (columns && columns.length >= 2) {
            // Remove quotes if present
            const filename = columns[1].replace(/"/g, '').trim();
            
            // Only add if it's a valid GLB filename
            if (filename.endsWith('.glb')) {
              allGlbFiles.push(filename);
            }
          }
        }
        
        console.log(`Loaded ${allGlbFiles.length} GLB files from CSV`);
        
        // If no files were found in the CSV, show an error
        if (allGlbFiles.length === 0) {
          console.error("No GLB files found in CSV file");
          return;
        }
        
        // Reset counters
        loadedCount = 0;
        failedCount = 0;
        loadingAttempted = false;
        
        // After loading files from CSV, filter by Unicode ranges
        allGlbFiles = filterByUnicodeRanges(allGlbFiles);
        
        // Now that we have the files, we can select some and load them
        const selectedFiles = shuffle([...allGlbFiles]).slice(0, params.modelCount);
        totalToLoad = selectedFiles.length;
        loadModels(selectedFiles);
        
      } catch (error) {
        console.error("Error loading CSV file:", error);
        displayLoadingError("Failed to load GLB files list from CSV");
      }
    }
    
    // Display error message in the 3D scene
    function displayLoadingError(errorMessage) {
      console.error(errorMessage);
      // Create a text div instead of 3D text (simpler solution)
      const errorDiv = document.createElement('div');
      errorDiv.style.position = 'absolute';
      errorDiv.style.top = '50%';
      errorDiv.style.left = '50%';
      errorDiv.style.transform = 'translate(-50%, -50%)';
      errorDiv.style.color = 'red';
      errorDiv.style.fontSize = '24px';
      errorDiv.style.fontWeight = 'bold';
      errorDiv.style.background = 'rgba(0,0,0,0.7)';
      errorDiv.style.padding = '20px';
      errorDiv.style.borderRadius = '10px';
      errorDiv.textContent = errorMessage;
      document.body.appendChild(errorDiv);
    }

    // Function to shuffle array (Fisher-Yates algorithm)
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {  // Fixed the decrement operator
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // GUI Controls setup
    const params = {
      scaleMultiplier: 100.0, // Default scale increased to 100
      showGrid: true,
      showBoundingBoxes: false,
      showLightHelpers: false,
      backgroundColor: '#000000',
      lightIntensity: 1.3, // Light set to 1.3
      spacing: 6,
      rotationSpeed: 0.005,
      bobSpeed: 0.002,
      driftSpeed: 0.001,
      driftAmount: 2.0,
      modelCount: 20, // Default model count set to 20
      distribution: 'random', // New distribution parameter
      material: 'plastic', // Default material set to plastic
      environment: {
        type: 'simple', // Environment map type
        intensity: 1.0,  // Environment map intensity
        colors: {          // Colors for procedural environment map
          top: '#0077ff',    // blue
          bottom: '#ff7700',  // orange
          front: '#00ff77',   // green
          back: '#ff0077',    // pink
          left: '#7700ff',    // purple  
          right: '#ffff00'    // yellow
        },
        rotation: 0,        // Environment map rotation
      },
      materialOptions: {
        glass: {
          metalness: 0.2,
          roughness: 0.1,
          transmission: 0.9,
          thickness: 0.5,
          ior: 1.5,
          transparent: true,
          opacity: 0.6,
          envMapIntensity: 1.0,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          attenuationDistance: 0.5,
          attenuationColor: 0xffffff
        },
        metal: {
          metalness: 1.0,
          roughness: 0.2,
          clearcoat: 0.8,
          clearcoatRoughness: 0.2,
          transparent: false,
          opacity: 1.0
        },
        plastic: {
          metalness: 0.0,
          roughness: 0.3,
          clearcoat: 0.4,
          transparent: false,
          opacity: 1.0
        },
        crystal: {
          metalness: 0.1,
          roughness: 0.0,
          transmission: 1.0,
          thickness: 1.0,
          ior: 2.4,
          transparent: true,
          opacity: 0.3,
          envMapIntensity: 2.0,
          clearcoat: 1.0,
          clearcoatRoughness: 0.0,
          attenuationDistance: 0.2,
          attenuationColor: 0xffffff
        },
        holographic: {
          metalness: 0.8,
          roughness: 0.2,
          transmission: 0.5,
          thickness: 0.5,
          ior: 1.7,
          transparent: true,
          opacity: 0.7,
          envMapIntensity: 2.0,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          attenuationDistance: 0.3,
          attenuationColor: 0x88ff88,
          iridescence: 1.0,
          iridescenceIOR: 2.0,
          sheen: 1.0,
          sheenRoughness: 0.4,
          sheenColor: 0x88ff88
        },
        neon: {
          metalness: 0.2,
          roughness: 0.1,
          transmission: 0.9,
          thickness: 0.2,
          ior: 1.6,
          transparent: true,
          opacity: 0.6,
          envMapIntensity: 3.0,
          emissive: 0xff00ff,
          emissiveIntensity: 2.0
        },
        pearl: {
          metalness: 0.7,
          roughness: 0.1,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          sheen: 1.0,
          sheenRoughness: 0.3,
          sheenColor: 0xffffff,
          iridescence: 0.8,
          iridescenceIOR: 1.5
        },
        chrome: {
          metalness: 1.0,
          roughness: 0.0,
          envMapIntensity: 2.5,
          clearcoat: 1.0,
          clearcoatRoughness: 0.0,
          opacity: 1.0
        },
        opal: {
          metalness: 0.1,
          roughness: 0.3,
          transmission: 0.6,
          thickness: 0.5,
          ior: 1.9,
          transparent: true,
          opacity: 0.7,
          iridescence: 1.0,
          iridescenceIOR: 2.2,
          sheen: 1.0,
          sheenRoughness: 0.2,
          sheenColor: 0xffffff,
          attenuationColor: 0xaaccff
        },
        liquid: {
          metalness: 0.0,
          roughness: 0.0,
          transmission: 1.0,
          thickness: 2.0,
          ior: 1.33,
          transparent: true,
          opacity: 0.6,
          envMapIntensity: 1.2,
          clearcoat: 0.5,
          attenuationDistance: 1.0,
          attenuationColor: 0x00ffff
        },
        plasma: {
          metalness: 0.3,
          roughness: 0.2,
          transmission: 0.5,
          thickness: 0.2,
          ior: 2.0,
          transparent: true,
          opacity: 0.7,
          emissive: 0x88ff88,
          emissiveIntensity: 2.0,
          envMapIntensity: 2.0,
          glow: true
        },
        rainbow: {
          metalness: 0.8,
          roughness: 0.2,
          clearcoat: 1.0,
          clearcoatRoughness: 0.2,
          iridescence: 1.0,
          iridescenceIOR: 2.0,
          sheen: 1.0,
          sheenRoughness: 0.2,
          sheenColor: 0xffffff
        }
      },
      unicodeRanges: {
        numbers: true,           // 0-9 with combining enclosing keycap
        symbols: true,           // Special symbols like ©®
        regionalIndicators: false, // Regional indicator symbols
        enclosedAlphanum: true,   // Enclosed alphanumerics
        misc: true,              // Miscellaneous symbols
        geometric: true,         // Geometric shapes (▲►▼◄)
        emotions: true,          // Emotion symbols
        weather: true,           // Weather & celestial symbols
        arrows: true,            // Arrow symbols
        math: true              // Mathematical symbols
      },
      reloadModels: () => {
        // Remove current models
        models.forEach(model => {
          scene.remove(model);
          if (model.userData.boxHelper) {
            scene.remove(model.userData.boxHelper);
          }
        });
        models.length = 0; // Clear array
        loadedCount = 0;
        failedCount = 0;
        
        // Load new models
        const newFiles = shuffle([...allGlbFiles]).slice(0, params.modelCount);
        totalToLoad = newFiles.length;
        loadModels(newFiles);
      },
      distributionOptions: {
        random: { name: 'Random', key: 'random' },
        grid3d: { name: '3D Grid', key: 'grid3d' },
        sphere: { name: 'Sphere', key: 'sphere' },
        cylinder: { name: 'Cylinder', key: 'cylinder' },
        spiral: { name: 'Spiral', key: 'spiral' },
        wave: { name: 'Wave', key: 'wave' }
      },
      animation: 'drift',
      animationOptions: {
        drift: { name: 'Drift' },
        wave: { name: 'Wave' },
        spiral: { name: 'Spiral' },
        orbit: { name: 'Orbit' }
      },
      waveSpeed: 1.0,
      waveHeight: 2.0,
      orbitSpeed: 0.5,
      spiralSpeed: 0.3
    };

    // Distribution settings
    params.distributionOptions = {
      random: { name: 'Random', key: 'random' },
      grid3d: { name: '3D Grid', key: 'grid3d', size: 3 },
      sphere: { name: 'Sphere', key: 'sphere', radius: 5 },
      cylinder: { name: 'Cylinder', key: 'cylinder', radius: 5, height: 10 },
      spiral: { name: 'Spiral', key: 'spiral', turns: 2, height: 10 },
      wave: { name: 'Wave', key: 'wave', frequency: 0.5, amplitude: 2 }
    };

    // Add environment map for better material appearance
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    
    // Create a simple environment map
    const envTexture = new THREE.CubeTextureLoader().load([
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==',
      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='
    ]);
    
    scene.environment = pmremGenerator.fromCubemap(envTexture).texture;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.physicallyCorrectLights = true;

    // Function to filter GLB files by Unicode ranges
    function filterByUnicodeRanges(files) {
      // If no files are provided, return an empty array
      if (!files || files.length === 0) {
        console.warn("No files provided to filter");
        return [];
      }
      
      console.log(`Filtering ${files.length} files by Unicode ranges`);
      
      // Create an array to store the regex patterns for each enabled range
      const ranges = [];
      
      if (params.unicodeRanges.numbers) {
        // 0-9 digits (0030-0039) and keycap versions (0030-0039 + 20E3)
        ranges.push(/emoji_u003[0-9](_20e3)?\.glb/);
      }
      
      if (params.unicodeRanges.symbols) {
        // Special symbols like copyright © (00A9) and registered ® (00AE)
        ranges.push(/emoji_u00(a9|ae)\.glb/);
      }
      
      if (params.unicodeRanges.regionalIndicators) {
        // Regional indicator symbols (1F1E6-1F1FF) - country flags
        ranges.push(/emoji_u1f1[e-f][0-9a-f]\.glb/);
      }
      
      if (params.unicodeRanges.enclosedAlphanum) {
        // Enclosed alphanumerics and symbols
        ranges.push(/emoji_u1f1[9][1-9a]\.glb/); // 1F191-1F19A
        ranges.push(/emoji_u1f20[1-2]\.glb/);    // 1F201-1F202
        ranges.push(/emoji_u1f21[a]\.glb/);      // 1F21A
        ranges.push(/emoji_u1f22[f]\.glb/);      // 1F22F
        ranges.push(/emoji_u1f23[2-a]\.glb/);    // 1F232-1F23A
        ranges.push(/emoji_u1f25[0-1]\.glb/);    // 1F250-1F251
      }
      
      if (params.unicodeRanges.geometric) {
        // Geometric shapes
        ranges.push(/emoji_u25[0-9a-f]{2}\.glb/);
      }
      
      if (params.unicodeRanges.emotions) {
        // Emotions and people
        ranges.push(/emoji_u1f6[0-9a-f]{2}\.glb/);
      }
      
      if (params.unicodeRanges.weather) {
        // Weather & celestial symbols
        ranges.push(/emoji_u2600\.glb/);         // Sun
        ranges.push(/emoji_u2601\.glb/);         // Cloud
        ranges.push(/emoji_u26[c][4-8]\.glb/);   // Weather
        ranges.push(/emoji_u1f30[0-9a-f]\.glb/); // Earth globe, sunrise, etc.
      }
      
      if (params.unicodeRanges.arrows) {
        // Arrow symbols
        ranges.push(/emoji_u2b0[0-9a-f]\.glb/);  // Various arrows
        ranges.push(/emoji_u27[0-9a-f]{2}\.glb/); // More arrows
      }
      
      if (params.unicodeRanges.math) {
        // Mathematical symbols
        ranges.push(/emoji_u2[2-3][0-9a-f]{2}\.glb/);
      }
      
      if (params.unicodeRanges.misc) {
        // Miscellaneous symbols (covers a lot of emoji categories)
        ranges.push(/emoji_u1f[3-9][0-9a-f]{2}\.glb/); // Broader range of misc symbols
      }
      
      // If no ranges are enabled, return all files
      if (ranges.length === 0) {
        console.warn("No Unicode ranges enabled, returning all files");
        return files;
      }
      
      // Filter files to only include those that match at least one of the enabled ranges
      const filteredFiles = files.filter(file => 
        ranges.some(range => range.test(file))
      );
      
      console.log(`Filtered to ${filteredFiles.length} files`);
      
      // If filtering resulted in no files, return the original set
      if (filteredFiles.length === 0) {
        console.warn("Filtering resulted in no files, returning all files");
        return files;
      }
      
      return filteredFiles;
    }

    // Setup GUI with new controls
    const gui = new GUI();
    gui.add(params, 'scaleMultiplier', 1, 100, 1).name('Scale').onChange(updateModels);
    gui.add(params, 'showGrid').name('Show Grid').onChange(value => {
      gridHelper.visible = value;
    });
    gui.add(params, 'showBoundingBoxes').name('Show Boxes').onChange(updateBoundingBoxes);
    gui.add(params, 'showLightHelpers').name('Show Light Helpers').onChange(value => {
      lightHelpers.forEach(helper => helper.visible = value);
      spotLightHelper.visible = value;
    });
    gui.addColor(params, 'backgroundColor').name('Background').onChange(value => {
      scene.background = new THREE.Color(value);
    });
    gui.add(params, 'lightIntensity', 0, 2, 0.1).name('Light').onChange(value => {
      updateLightIntensity(value);
    });
    gui.add(params, 'material', [
      'glass', 'metal', 'plastic', 'crystal', 'holographic', 
      'neon', 'pearl', 'chrome', 'opal', 'liquid', 'plasma', 'rainbow'
    ]).name('Material').onChange(updateMaterials);
    gui.add(params, 'spacing', 2, 15, 0.5).name('Spacing').onChange(updateModelPositions);
    gui.add(params, 'rotationSpeed', 0, 0.05, 0.001).name('Rotation Speed');
    gui.add(params, 'bobSpeed', 0, 0.01, 0.0001).name('Bob Speed');
    gui.add(params, 'driftSpeed', 0, 0.01, 0.0001).name('Drift Speed');
    gui.add(params, 'driftAmount', 0, 5, 0.1).name('Drift Range');
    gui.add(params, 'modelCount', 1, 20, 1).name('Model Count');
    
    // Environment map controls in their own folder
    const envFolder = gui.addFolder('Environment Map');
    envFolder.add(params.environment, 'type', ['simple', 'procedural', 'colorful']).name('Type')
      .onChange(() => updateEnvironmentMap());
    envFolder.add(params.environment, 'intensity', 0, 3, 0.1).name('Intensity')
      .onChange(() => updateMaterials());
    envFolder.add(params.environment, 'rotation', 0, Math.PI * 2, 0.01).name('Rotation')
      .onChange(() => updateEnvironmentRotation());
    
    // Color controls for environment map sides
    const envColorFolder = envFolder.addFolder('Environment Colors');
    envColorFolder.addColor(params.environment.colors, 'top').name('Top')
      .onChange(() => updateEnvironmentMap());
    envColorFolder.addColor(params.environment.colors, 'bottom').name('Bottom')
      .onChange(() => updateEnvironmentMap());
    envColorFolder.addColor(params.environment.colors, 'front').name('Front')
      .onChange(() => updateEnvironmentMap());
    envColorFolder.addColor(params.environment.colors, 'back').name('Back')
      .onChange(() => updateEnvironmentMap());
    envColorFolder.addColor(params.environment.colors, 'left').name('Left')
      .onChange(() => updateEnvironmentMap());
    envColorFolder.addColor(params.environment.colors, 'right').name('Right')
      .onChange(() => updateEnvironmentMap());
    
    // Unicode range controls
    const rangeFolder = gui.addFolder('Unicode Ranges');
    rangeFolder.add(params.unicodeRanges, 'numbers').name('Numbers 0-9');
    rangeFolder.add(params.unicodeRanges, 'symbols').name('Symbols ©®');
    rangeFolder.add(params.unicodeRanges, 'regionalIndicators').name('Regional');
    rangeFolder.add(params.unicodeRanges, 'enclosedAlphanum').name('Enclosed');
    rangeFolder.add(params.unicodeRanges, 'geometric').name('Geometric');
    rangeFolder.add(params.unicodeRanges, 'emotions').name('Emotions');
    rangeFolder.add(params.unicodeRanges, 'weather').name('Weather');
    rangeFolder.add(params.unicodeRanges, 'arrows').name('Arrows');
    rangeFolder.add(params.unicodeRanges, 'math').name('Math');
    rangeFolder.add(params.unicodeRanges, 'misc').name('Misc Symbols');
    
    gui.add(params, 'reloadModels').name('Reload Models');

    // Add distribution and animation controls to GUI
    const distributionFolder = gui.addFolder('Distribution');
    distributionFolder.add(params, 'distribution', [
      'random',
      'grid3d',
      'sphere',
      'cylinder',
      'spiral',
      'wave'
    ]).name('Distribution')
      .onChange(() => {
        console.log('Changing distribution to:', params.distribution);
        updateModelPositions();
      });
    
    const animationFolder = gui.addFolder('Animation');
    animationFolder.add(params, 'animation', 
      Object.fromEntries(Object.entries(params.animationOptions).map(([k, v]) => [k, v.name]))
    ).onChange(() => {
      console.log('Changing animation to:', params.animation);
      // Reset positions to their original distribution positions
      // before applying the new animation
      models.forEach((model) => {
        if (model.userData.originalPosition) {
          model.position.copy(model.userData.originalPosition);
        }
      });
    });
    
    // Update animation parameters dynamically
    animationFolder.add(params, 'waveSpeed', 0, 2).name('Wave Speed')
      .onChange(() => console.log('Wave speed updated:', params.waveSpeed));
    animationFolder.add(params, 'waveHeight', 0, 5).name('Wave Height')
      .onChange(() => console.log('Wave height updated:', params.waveHeight));
    animationFolder.add(params, 'orbitSpeed', 0, 2).name('Orbit Speed')
      .onChange(() => console.log('Orbit speed updated:', params.orbitSpeed));
    animationFolder.add(params, 'spiralSpeed', 0, 2).name('Spiral Speed')
      .onChange(() => console.log('Spiral speed updated:', params.spiralSpeed));

    // Define folder path
    const folderPath = './glb_flat/';

    // GLTF Loader
    const loader = new GLTFLoader();
    const models = [];

    // Function to update model scales
    function updateModels() {
      models.forEach(model => {
        model.scale.set(params.scaleMultiplier, params.scaleMultiplier, params.scaleMultiplier);
        if (model.userData.boxHelper) {
          const box = new THREE.Box3().setFromObject(model);
          model.userData.boxHelper.box.copy(box);
        }
      });
    }

    // Function to update bounding box visibility
    function updateBoundingBoxes() {
      models.forEach(model => {
        if (model.userData.boxHelper) {
          model.userData.boxHelper.visible = params.showBoundingBoxes;
        }
      });
    }

    // Function to update light intensity
    function updateLightIntensity(value) {
      scene.children.forEach(child => {
        if (child instanceof THREE.Light) {
          child.intensity = value;
        }
      });
    }

    // Distribution functions
    const distributions = {
      random: (index, total) => {
        return new THREE.Vector3(
          (Math.random() - 0.5) * params.spacing * 2,
          (Math.random() - 0.5) * params.spacing * 2,
          (Math.random() - 0.5) * params.spacing * 2
        );
      },
      grid3d: (index, total) => {
        const gridSize = Math.ceil(Math.pow(total, 1/3));
        const spacing = params.spacing;
        
        const x = (index % gridSize - gridSize/2) * spacing;
        const y = (Math.floor(index/gridSize) % gridSize - gridSize/2) * spacing;
        const z = (Math.floor(index/(gridSize*gridSize)) - gridSize/2) * spacing;
        
        return new THREE.Vector3(x, y, z);
      },
      sphere: (index, total) => {
        const radius = params.spacing * 2;
        const phi = Math.acos(-1 + (2 * index) / total);
        const theta = Math.sqrt(total * Math.PI) * phi;
        
        return new THREE.Vector3(
          radius * Math.cos(theta) * Math.sin(phi),
          radius * Math.sin(theta) * Math.sin(phi),
          radius * Math.cos(phi)
        );
      },
      cylinder: (index, total) => {
        const radius = params.spacing * 2;
        const height = params.spacing * 4;
        const angle = (index / total) * Math.PI * 2;
        const y = (index / total - 0.5) * height;
        
        return new THREE.Vector3(
          radius * Math.cos(angle),
          y,
          radius * Math.sin(angle)
        );
      },
      spiral: (index, total) => {
        const radius = (index / total) * params.spacing * 4;
        const angle = (index / total) * Math.PI * 8;
        const y = (index / total - 0.5) * params.spacing * 4;
        
        return new THREE.Vector3(
          radius * Math.cos(angle),
          y,
          radius * Math.sin(angle)
        );
      },
      wave: (index, total) => {
        const spacing = params.spacing;
        const x = (index - total/2) * spacing;
        const z = (index % 2) * spacing - spacing/2;
        const y = Math.sin(x * 0.5) * spacing;
        
        return new THREE.Vector3(x, y, z);
      }
    };

    // Function to update model positions
    function updateModelPositions() {
      console.log('Updating positions with distribution:', params.distribution);
      const distribute = distributions[params.distribution];
      if (!distribute) {
        console.error('Invalid distribution:', params.distribution);
        return;
      }
      
      models.forEach((model, index) => {
        const position = distribute(index, models.length);
        if (position) {
          model.position.copy(position);
          // Store initial position for animations
          model.userData.originalPosition = position.clone();
          model.userData.initialAngle = (index / models.length) * Math.PI * 2;
        }
      });
    }

    // Function to try loading additional models if some fail
    function tryLoadAdditionalModels() {
      // If we have fewer than desired models loaded and there are still files available
      if (loadedCount < params.modelCount && loadedCount + failedCount < allGlbFiles.length) {
        const remainingToLoad = params.modelCount - loadedCount;
        const additionalFiles = shuffle([...allGlbFiles])
          .filter(file => !models.some(m => m.userData && m.userData.fileName === file))
          .slice(0, remainingToLoad + 5); // Load some extra to account for possible failures
        
        if (additionalFiles.length > 0) {
          console.log(`Trying to load ${additionalFiles.length} additional models`);
          loadModels(additionalFiles);
        } else {
          console.warn(`Only able to load ${loadedCount} out of ${params.modelCount} requested models`);
        }
      }
    }

    // Function to update materials on all models
    function updateMaterials() {
      const materialOpts = params.materialOptions[params.material];
      
      // Adjust environment map intensity for all materials
      const envIntensity = params.envMapIntensity;
      
      models.forEach(model => {
        model.traverse(child => {
          if (child.isMesh) {
            if (!child.userData.originalMaterial) {
              child.userData.originalMaterial = child.material.clone();
            }
            
            const newMaterial = new THREE.MeshPhysicalMaterial({
              color: child.userData.originalMaterial.color,
              ...materialOpts,
              envMapIntensity: materialOpts.envMapIntensity ? materialOpts.envMapIntensity * envIntensity : envIntensity,
              side: THREE.DoubleSide
            });
            
            // Add emissive properties for glowing materials
            if (materialOpts.glow) {
              newMaterial.emissive = child.userData.originalMaterial.color;
              newMaterial.emissiveIntensity = 0.5;
            }
            
            child.material = newMaterial;
          }
        });
      });
      
      // Update environment map if needed
      if (params.envMapType !== currentEnvMapType) {
        updateEnvironmentMap();
      }
    }
    
    // Track current environment map type and the environment map object
    let currentEnvMapType = 'simple';
    let currentEnvMap = null;
    
    // Function to update environment rotation
    function updateEnvironmentRotation() {
      if (!scene.environment) return;
      
      // We'll need to update the rotation matrix of the environment map
      if (!scene.environment.userData) scene.environment.userData = {};
      
      // Create rotation matrix with current rotation value
      const rotation = new THREE.Matrix4().makeRotationY(params.environment.rotation);
      scene.environment.userData.rotation = rotation;
      
      // Apply rotation to environment map
      // Note: This is a simplified version - in a more complete implementation,
      // you would need to re-render the environment with the new rotation
      
      console.log('Updating environment rotation:', params.environment.rotation);
      
      // Force materials to update to reflect the new environment rotation
      models.forEach(model => {
        model.traverse(child => {
          if (child.material) {
            child.material.needsUpdate = true;
          }
        });
      });
    }
    
    // Function to update environment map
    function updateEnvironmentMap() {
      const prevEnvMapType = currentEnvMapType;
      currentEnvMapType = params.environment.type;
      
      console.log('Updating environment map to:', params.environment.type);
      
      if (params.environment.type === 'simple') {
        // Use the basic environment map (already defined)
        scene.environment = pmremGenerator.fromCubemap(envTexture).texture;
        currentEnvMap = scene.environment;
        console.log('Using simple environment map');
      } else if (params.environment.type === 'procedural') {
        // Create a procedural environment with solid colors
        const rt = new THREE.WebGLCubeRenderTarget(256);
        rt.texture.type = THREE.HalfFloatType;
        
        const cubeCamera = new THREE.CubeCamera(0.1, 10, rt);
        
        // Create a scene with solid color sides
        const envScene = new THREE.Scene();
        
        // Use colors from parameters
        const colors = [
          new THREE.Color(params.environment.colors.right), // positive x
          new THREE.Color(params.environment.colors.left),  // negative x
          new THREE.Color(params.environment.colors.top),   // positive y
          new THREE.Color(params.environment.colors.bottom),// negative y
          new THREE.Color(params.environment.colors.front), // positive z
          new THREE.Color(params.environment.colors.back)   // negative z
        ];
        
        // Create a cube with different colors for each face
        const geometry = new THREE.BoxGeometry(10, 10, 10);
        
        // Modify UV coordinates to map each face to a solid color
        for (let i = 0; i < 6; i++) {
          const material = new THREE.MeshBasicMaterial({
            side: THREE.BackSide,
            color: colors[i],
            transparent: false
          });
          
          const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            material
          );
          
          // Position and rotate the plane to form a cube
          switch(i) {
            case 0: // +X
              mesh.position.set(5, 0, 0);
              mesh.rotation.set(0, Math.PI/2, 0);
              break;
            case 1: // -X
              mesh.position.set(-5, 0, 0);
              mesh.rotation.set(0, -Math.PI/2, 0);
              break;
            case 2: // +Y
              mesh.position.set(0, 5, 0);
              mesh.rotation.set(-Math.PI/2, 0, 0);
              break;
            case 3: // -Y
              mesh.position.set(0, -5, 0);
              mesh.rotation.set(Math.PI/2, 0, 0);
              break;
            case 4: // +Z
              mesh.position.set(0, 0, 5);
              mesh.rotation.set(0, 0, 0);
              break;
            case 5: // -Z
              mesh.position.set(0, 0, -5);
              mesh.rotation.set(0, Math.PI, 0);
              break;
          }
          
          envScene.add(mesh);
        }
        
        // Render the env scene
        cubeCamera.update(renderer, envScene);
        
        // Set the environment map
        scene.environment = pmremGenerator.fromCubemap(rt.texture).texture;
        currentEnvMap = scene.environment;
        console.log('Using procedural environment map');
      } else if (params.environment.type === 'colorful') {
        // Create a more colorful gradient environment
        const rt = new THREE.WebGLCubeRenderTarget(256);
        rt.texture.type = THREE.HalfFloatType;
        
        const cubeCamera = new THREE.CubeCamera(0.1, 10, rt);
        
        // Create a scene with gradient backgrounds
        const envScene = new THREE.Scene();
        
        // Create gradient materials for each face
        for (let i = 0; i < 6; i++) {
          // Create a canvas for the gradient
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const ctx = canvas.getContext('2d');
          
          // Define gradient based on face
          let gradient;
          switch(i) {
            case 0: // right (+X)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.right);
              gradient.addColorStop(1, params.environment.colors.top);
              break;
            case 1: // left (-X)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.left);
              gradient.addColorStop(1, params.environment.colors.bottom);
              break;
            case 2: // top (+Y)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.top);
              gradient.addColorStop(1, params.environment.colors.front);
              break;
            case 3: // bottom (-Y)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.bottom);
              gradient.addColorStop(1, params.environment.colors.back);
              break;
            case 4: // front (+Z)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.front);
              gradient.addColorStop(1, params.environment.colors.right);
              break;
            case 5: // back (-Z)
              gradient = ctx.createLinearGradient(0, 0, 256, 256);
              gradient.addColorStop(0, params.environment.colors.back);
              gradient.addColorStop(1, params.environment.colors.left);
              break;
          }
          
          // Fill with gradient
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 256, 256);
          
          // Create texture from canvas
          const texture = new THREE.CanvasTexture(canvas);
          
          const material = new THREE.MeshBasicMaterial({
            side: THREE.BackSide,
            map: texture
          });
          
          const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(10, 10),
            material
          );
          
          // Position and rotate the plane to form a cube
          switch(i) {
            case 0: // +X
              mesh.position.set(5, 0, 0);
              mesh.rotation.set(0, Math.PI/2, 0);
              break;
            case 1: // -X
              mesh.position.set(-5, 0, 0);
              mesh.rotation.set(0, -Math.PI/2, 0);
              break;
            case 2: // +Y
              mesh.position.set(0, 5, 0);
              mesh.rotation.set(-Math.PI/2, 0, 0);
              break;
            case 3: // -Y
              mesh.position.set(0, -5, 0);
              mesh.rotation.set(Math.PI/2, 0, 0);
              break;
            case 4: // +Z
              mesh.position.set(0, 0, 5);
              mesh.rotation.set(0, 0, 0);
              break;
            case 5: // -Z
              mesh.position.set(0, 0, -5);
              mesh.rotation.set(0, Math.PI, 0);
              break;
          }
          
          envScene.add(mesh);
        }
        
        // Render the env scene
        cubeCamera.update(renderer, envScene);
        
        // Set the environment map
        scene.environment = pmremGenerator.fromCubemap(rt.texture).texture;
        currentEnvMap = scene.environment;
        console.log('Using colorful gradient environment map');
      }
      
      // Apply rotation if needed
      if (params.environment.rotation !== 0) {
        updateEnvironmentRotation();
      }
      
      // Update materials to use the new environment map
      updateMaterials();
    }

    // Function to load models
    function loadModels(fileList) {
      fileList.forEach((fileName) => {
        loader.load(
          folderPath + fileName,
          function (gltf) {
            const model = gltf.scene;
            model.userData.fileName = fileName;
            model.scale.set(params.scaleMultiplier, params.scaleMultiplier, params.scaleMultiplier);
            
            // Set initial position using selected distribution
            const distribute = distributions[params.distribution];
            const position = distribute ? distribute(models.length, params.modelCount) : new THREE.Vector3();
            model.position.copy(position);
            model.userData.originalPosition = position.clone();
            
            // Random rotation direction
            model.userData.rotationAxis = new THREE.Vector3(
              Math.random() - 0.5,
              Math.random() - 0.5,
              Math.random() - 0.5
            ).normalize();
            model.userData.rotationSpeed = Math.random() * 0.01 + 0.002;
            model.userData.initialAngle = Math.random() * Math.PI * 2;
            
            // Add a bounding box helper to visualize model size
            const box = new THREE.Box3().setFromObject(model);
            const boxHelper = new THREE.Box3Helper(box, 0xffff00);
            boxHelper.visible = params.showBoundingBoxes;
            scene.add(boxHelper);
            model.userData.boxHelper = boxHelper;
            
            // Apply initial material
            model.traverse(child => {
              if (child.isMesh) {
                child.userData.originalMaterial = child.material.clone();
                const materialOpts = params.materialOptions[params.material];
                child.material = new THREE.MeshPhysicalMaterial({
                  color: child.userData.originalMaterial.color,
                  ...materialOpts,
                  side: THREE.DoubleSide
                });
              }
            });
            
            scene.add(model);
            models.push(model);
            loadedCount++;
            
            // Log model dimensions for debugging
            const size = new THREE.Vector3();
            box.getSize(size);
            console.log(`Loaded model: ${fileName} (${loadedCount}/${params.modelCount})`);
            console.log(`Model dimensions: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`);
          },
          function (progress) {
            // Loading progress
            const percent = (progress.loaded / progress.total) * 100;
            if (percent === 100 || percent % 25 === 0) { // Log at 0%, 25%, 50%, 75%, 100%
              console.log(`Loading ${fileName}: ${percent.toFixed(0)}%`);
            }
          },
          function (error) {
            // Error callback
            console.warn(`File not found or error loading ${fileName}`, error.message);
            failedCount++;
            
            // Try to load another model if this one failed
            if (loadedCount < params.modelCount) {
              setTimeout(() => tryLoadAdditionalModels(), 0);
            }
          }
        );
      });
    }

    // Animation functions
    const animations = {
      drift: (model, time) => {
        // Initialize position data if not set
        if (!model.userData.originalPosition) {
          model.userData.originalPosition = model.position.clone();
        }
        if (!model.userData.driftPhase) {
          model.userData.driftPhase = {
            x: Math.random() * Math.PI * 2,
            y: Math.random() * Math.PI * 2,
            z: Math.random() * Math.PI * 2
          };
        }
        
        const pos = model.position;
        const orig = model.userData.originalPosition;
        const phase = model.userData.driftPhase;
        
        pos.x = orig.x + Math.sin(time * 0.5 + phase.x) * params.driftAmount;
        pos.y = orig.y + Math.sin(time * 0.7 + phase.y) * params.bobSpeed;
        pos.z = orig.z + Math.cos(time * 0.3 + phase.z) * params.driftAmount;
      },
      wave: (model, time) => {
        if (!model.userData.originalPosition) {
          model.userData.originalPosition = model.position.clone();
        }
        
        const pos = model.position;
        const orig = model.userData.originalPosition;
        const waveX = Math.sin(time * params.waveSpeed + orig.x * 0.1) * params.waveHeight;
        const waveZ = Math.cos(time * params.waveSpeed + orig.z * 0.1) * params.waveHeight;
        pos.y = orig.y + waveX + waveZ;
      },
      spiral: (model, time) => {
        if (!model.userData.originalPosition) {
          model.userData.originalPosition = model.position.clone();
        }
        if (!model.userData.initialAngle) {
          model.userData.initialAngle = Math.random() * Math.PI * 2;
        }
        
        const pos = model.position;
        const orig = model.userData.originalPosition;
        const angle = time * params.spiralSpeed + model.userData.initialAngle;
        const radius = orig.length();
        pos.x = Math.cos(angle) * radius;
        pos.z = Math.sin(angle) * radius;
        pos.y = orig.y + Math.sin(time) * params.bobSpeed;
      },
      orbit: (model, time) => {
        if (!model.userData.originalPosition) {
          model.userData.originalPosition = model.position.clone();
        }
        if (!model.userData.initialAngle) {
          model.userData.initialAngle = Math.random() * Math.PI * 2;
        }
        
        const pos = model.position;
        const orig = model.userData.originalPosition;
        const angle = time * params.orbitSpeed + model.userData.initialAngle;
        const radius = orig.length();
        const elevation = Math.sin(time * 0.5) * params.bobSpeed;
        
        pos.x = Math.cos(angle) * radius;
        pos.y = orig.y + elevation;
        pos.z = Math.sin(angle) * radius;
      }
    };

    // Post-processing setup
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.5,   // strength
      0.4,   // radius
      0.85   // threshold
    );
    composer.addPass(bloomPass);

    // Custom glow shader
    const GlowShader = {
      uniforms: {
        tDiffuse: { value: null },
        glowColor: { value: new THREE.Color(0x000033) }, // Very dark blue glow color
        glowIntensity: { value: 0.5 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec3 glowColor;
        uniform float glowIntensity;
        varying vec2 vUv;
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          vec3 glow = glowColor * glowIntensity;
          gl_FragColor = vec4(texel.rgb + glow, texel.a);
        }
      `
    };

    const glowPass = new ShaderPass(GlowShader);
    composer.addPass(glowPass);

    // Add post-processing parameters to GUI
    const postProcessingFolder = gui.addFolder('Post Processing');
    postProcessingFolder.add(bloomPass, 'strength', 0, 3).name('Bloom Strength');
    postProcessingFolder.add(bloomPass, 'radius', 0, 1).name('Bloom Radius');
    postProcessingFolder.add(bloomPass, 'threshold', 0, 1).name('Bloom Threshold');
    postProcessingFolder.add(glowPass.uniforms.glowIntensity, 'value', 0, 1).name('Glow Intensity');
    
    // Add color picker for glow
    postProcessingFolder.addColor({color: '#000033'}, 'color')
      .name('Glow Color')
      .onChange(value => {
        glowPass.uniforms.glowColor.value.setHex(parseInt(value.replace('#', '0x')));
      });

    // Modify material options to include emissive properties
    params.materialOptions.neon.glow = true;
    params.materialOptions.holographic.glow = true;

    // Enhanced animation function
    function animate() {
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001; // Current time in seconds
      
      models.forEach((model) => {
        // Apply selected animation
        const animationFunc = animations[params.animation];
        if (animationFunc) {
          animationFunc(model, time);
        }
        
        // Continue with rotation and other effects
        if (model.userData.rotationAxis) {
          const rotationMatrix = new THREE.Matrix4();
          rotationMatrix.makeRotationAxis(
            model.userData.rotationAxis,
            params.rotationSpeed
          );
          model.matrix.multiply(rotationMatrix);
          model.rotation.setFromRotationMatrix(model.matrix);
        }
        
        // Update bounding box position
        if (model.userData.boxHelper) {
          const box = new THREE.Box3().setFromObject(model);
          model.userData.boxHelper.box.copy(box);
        }
      });
      
      controls.update();
      composer.render();
    }
    
    // Start the application by loading the CSV file first
    loadGlbFilesFromCSV();
    
    // Start animation loop
    animate();

    // Responsive resizing
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
      bloomPass.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
